# IQE系统架构分析报告：数据同步→规则库→规则执行

## 📋 概述

本报告分析IQE智能质检系统中数据同步到规则库、规则建立以及规则执行的完整程序设计架构。

## 🏗️ 系统整体架构

### 核心组件关系图
```
前端数据 → 数据同步服务 → 数据库 → 规则库 → 规则执行引擎 → API响应
    ↓           ↓           ↓        ↓         ↓
localStorage → DataSync → MySQL → NLP Rules → SQL Processor
```

## 1️⃣ 数据同步层 (Data Synchronization Layer)

### 1.1 核心服务文件
- **主服务**: `backend/src/services/DataSyncService.js`
- **前端数据服务**: `backend/src/services/frontendDataService.js`
- **路由**: `backend/src/routes/dataSyncRoutes.js`

### 1.2 数据同步流程

#### 步骤1: 前端数据获取
```javascript
// 从前端localStorage获取数据
const frontendData = {
  inventory: [],    // 库存数据 (132条)
  inspection: [],   // 检验数据 (396条)
  production: []    // 生产数据 (1056条)
};
```

#### 步骤2: 数据验证与转换
```javascript
// 数据格式验证
const expectedKeys = ['inventory', 'inspection', 'production'];
const hasValidData = expectedKeys.some(key => 
  data[key] && Array.isArray(data[key]) && data[key].length > 0
);
```

#### 步骤3: 数据库同步
```javascript
// 同步到MySQL数据库
await syncToDatabase(frontendData);
// 更新内存缓存
memoryData = { ...frontendData, lastSync: new Date().toISOString() };
```

### 1.3 API端点
- `POST /api/data-sync/sync` - 执行数据同步
- `GET /api/data-sync/status` - 获取同步状态
- `POST /api/assistant/update-data` - 更新助手数据
- `POST /api/assistant/verify-data` - 验证数据完整性

## 2️⃣ 规则库管理层 (Rule Management Layer)

### 2.1 数据库设计

#### 核心表结构
```sql
-- NLP意图规则表
CREATE TABLE `nlp_intent_rules` (
  `id` INT AUTO_INCREMENT PRIMARY KEY,
  `intent_name` VARCHAR(100) NOT NULL,      -- 规则名称
  `description` TEXT,                       -- 规则描述
  `action_type` VARCHAR(50),                -- 动作类型 (SQL_QUERY)
  `action_target` TEXT,                     -- SQL查询模板
  `parameters` JSON,                        -- 参数定义
  `trigger_words` JSON,                     -- 触发词
  `synonyms` JSON,                          -- 同义词
  `example_query` VARCHAR(200),             -- 示例查询
  `category` VARCHAR(50),                   -- 分类
  `priority` INT DEFAULT 0,                 -- 优先级
  `sort_order` INT DEFAULT 0,               -- 排序
  `status` VARCHAR(20) DEFAULT 'active'     -- 状态
);
```

#### 业务数据表
```sql
-- 库存表
CREATE TABLE `inventory` (
  `material_code` VARCHAR(50),    -- 物料编码
  `material_name` VARCHAR(100),   -- 物料名称
  `supplier_name` VARCHAR(100),   -- 供应商
  `quantity` INT,                 -- 数量
  `status` VARCHAR(20),           -- 状态
  `storage_location` VARCHAR(50), -- 存储位置
  -- ... 其他字段
);
```

### 2.2 规则建立流程

#### 规则设计原则
1. **分层设计**: 基础规则 → 复杂规则 → 综合规则
2. **场景驱动**: 库存场景、测试场景、上线场景、批次场景
3. **字段对齐**: 规则输出字段与前端页面字段完全对应

#### 规则分类体系
```javascript
const ruleCategories = {
  '库存场景': [
    '物料库存信息查询_优化',
    '供应商库存查询_优化',
    '库存状态查询',
    // ...
  ],
  '测试场景': [
    'NG测试结果查询_优化',
    '物料测试结果查询_优化',
    'Top缺陷排行查询',
    // ...
  ],
  '上线场景': [
    '物料上线跟踪查询_优化',
    '批次上线情况查询_优化',
    // ...
  ],
  '批次场景': [
    '批次综合信息查询_优化',
    '异常批次识别_优化',
    // ...
  ]
};
```

### 2.3 规则管理API
- `GET /api/rules` - 获取所有规则
- `POST /api/rules/test/:id` - 测试单个规则
- `POST /api/rules/test-all` - 批量测试规则
- `PUT /api/rules/:id` - 更新规则
- `DELETE /api/rules/:id` - 删除规则

## 3️⃣ 规则执行引擎 (Rule Execution Engine)

### 3.1 核心执行服务

#### 主要服务文件
- **意图匹配**: `backend/src/services/enhancedNLPService.js`
- **SQL处理器**: `backend/src/services/SQLRuleProcessor.js`
- **优化处理器**: `backend/src/services/optimizedRuleProcessor.js`
- **助手服务**: `backend/src/services/assistantService.js`

### 3.2 执行流程

#### 步骤1: 查询解析
```javascript
// 用户查询 → 意图识别
const matchedRule = enhancedIntentMatching(queryText);
// 参数提取
const parameters = extractParameters(queryText, matchedRule);
```

#### 步骤2: 规则匹配算法
```javascript
function enhancedIntentMatching(queryText) {
  let bestMatch = null;
  let bestScore = 0;
  
  for (const rule of intentRules) {
    let score = 0;
    
    // 1. 规则名称匹配 (权重最高)
    if (rule.intent_name && queryText.includes(rule.intent_name)) {
      score += 50;
    }
    
    // 2. 触发词匹配
    if (rule.trigger_words) {
      // 触发词匹配逻辑
    }
    
    // 3. 同义词匹配
    if (rule.synonyms) {
      // 同义词匹配逻辑
    }
    
    if (score > bestScore) {
      bestScore = score;
      bestMatch = rule;
    }
  }
  
  return bestMatch;
}
```

#### 步骤3: SQL执行
```javascript
// SQL模板处理
function processSQLRule(rule, query, memoryData) {
  // 转换规则为SQL查询
  const sql = convertRuleToSQL(rule, query);
  
  // 执行SQL查询 (优先MySQL，降级到内存查询)
  const results = executeSQL(sql, memoryData);
  
  // 生成回答
  const answer = generateAnswer(rule, query, results);
  
  return { success: true, data: { answer, tableData: results } };
}
```

### 3.3 执行策略

#### 双引擎策略
1. **MySQL引擎**: 优先使用数据库查询
2. **内存引擎**: MySQL失败时降级到内存数据查询

#### 优化规则处理
```javascript
// 检测优化规则
const optimizedIntents = [
  'count_inventory_items', 'count_material_types', 
  'count_material_batches', 'count_projects'
];

if (optimizedIntents.includes(detectedIntent)) {
  return processOptimizedRule(queryText, detectedIntent);
}
```

## 4️⃣ 系统集成架构

### 4.1 服务启动流程
```javascript
// backend/src/index.js
async function startServer() {
  // 1. 初始化数据库
  await initializeDatabase();
  
  // 2. 加载NLP规则
  await loadIntentRules();
  
  // 3. 启动服务器
  server.listen(PORT);
}
```

### 4.2 路由架构
```javascript
// backend/src/routes.js
export function setupRoutes(app) {
  app.use('/api/assistant', assistantRoutes);     // 助手服务
  app.use('/api/data', dataRoutes);               // 数据管理
  app.use('/api/rules', rulesRoutes);             // 规则管理
  app.use('/api/data-sync', dataSyncRoutes);      // 数据同步
  // ...
}
```

### 4.3 中间件架构
- **请求日志**: `requestLogger`
- **错误处理**: `errorHandler`
- **限流控制**: 分层限流策略
- **安全防护**: `helmet`, `cors`

## 5️⃣ 数据流向图

```
用户查询
    ↓
前端界面 (Vue.js)
    ↓
API请求 (/api/assistant/query)
    ↓
助手控制器 (assistantController.js)
    ↓
意图匹配服务 (enhancedNLPService.js)
    ↓
规则执行引擎 (SQLRuleProcessor.js)
    ↓
数据库查询 (MySQL) / 内存查询
    ↓
结果格式化 (ResponseFormatterService.js)
    ↓
API响应
    ↓
前端展示
```

## 6️⃣ 关键设计特点

### 6.1 容错机制
- **双引擎降级**: MySQL → 内存查询
- **规则匹配容错**: 模糊匹配 + 同义词支持
- **数据验证**: 多层数据完整性检查

### 6.2 性能优化
- **内存缓存**: 实时数据缓存机制
- **索引优化**: 数据库字段索引设计
- **分层限流**: 差异化API限流策略

### 6.3 扩展性设计
- **模块化架构**: 服务分离，职责清晰
- **配置驱动**: 规则可配置，易于扩展
- **标准化接口**: 统一的API设计规范

## 7️⃣ 监控与日志

### 7.1 日志系统
- **请求日志**: Morgan + 自定义请求日志
- **业务日志**: Winston日志框架
- **性能监控**: 请求时间、内存使用监控

### 7.2 健康检查
- **服务状态**: `/health` 端点
- **数据库连接**: 连接状态监控
- **规则加载**: 规则库状态检查

## 8️⃣ 核心代码示例

### 8.1 数据同步核心代码
```javascript
// backend/src/services/DataSyncService.js
export async function syncFrontendData(frontendData) {
  try {
    // 同步库存数据
    if (frontendData.inventory && Array.isArray(frontendData.inventory)) {
      memoryData.inventory = frontendData.inventory;
      logger.info(`同步库存数据: ${memoryData.inventory.length} 条记录`);
    }

    // 同步检验数据
    if (frontendData.inspection && Array.isArray(frontendData.inspection)) {
      memoryData.inspection = frontendData.inspection;
      logger.info(`同步检验数据: ${memoryData.inspection.length} 条记录`);
    }

    // 同步生产数据
    if (frontendData.production && Array.isArray(frontendData.production)) {
      memoryData.production = frontendData.production;
      logger.info(`同步生产数据: ${memoryData.production.length} 条记录`);
    }

    // 更新同步时间
    memoryData.lastSync = new Date().toISOString();

    // 保存到数据库
    await saveToDatabase(memoryData);

    return {
      success: true,
      message: '数据同步成功',
      data: {
        inventoryCount: memoryData.inventory.length,
        inspectionCount: memoryData.inspection.length,
        productionCount: memoryData.production.length,
        lastSync: memoryData.lastSync
      }
    };
  } catch (error) {
    logger.error('数据同步失败:', error);
    return {
      success: false,
      message: '数据同步失败: ' + error.message
    };
  }
}
```

### 8.2 规则匹配核心算法
```javascript
// backend/src/services/enhancedNLPService.js
export function enhancedIntentMatching(queryText) {
  const queryLower = queryText.toLowerCase();
  let bestMatch = null;
  let bestScore = 0;

  for (const rule of enhancedIntentRules) {
    let score = 0;
    let matchedKeywords = 0;

    // 关键词匹配
    for (const keyword of rule.keywords) {
      if (queryLower.includes(keyword.toLowerCase())) {
        matchedKeywords++;
        score += keyword.length; // 长关键词权重更高
      }
    }

    // 计算匹配分数
    if (matchedKeywords > 0) {
      score = score * matchedKeywords / rule.keywords.length;

      // 如果当前分数更高，更新最佳匹配
      if (score > bestScore) {
        bestScore = score;
        bestMatch = rule;
      }
    }
  }

  return bestScore > 0 ? bestMatch : null;
}
```

### 8.3 SQL规则执行核心代码
```javascript
// backend/src/services/SQLRuleProcessor.js
export function processSQLRule(rule, query, memoryData) {
  try {
    logger.info('处理SQL规则:', rule.intent_name);

    // 转换规则为SQL查询
    const sql = convertRuleToSQL(rule, query);
    logger.debug('生成的SQL查询:', sql);

    // 执行SQL查询
    const results = executeSQL(sql, memoryData);

    // 生成回答
    const answer = generateAnswer(rule, query, results);

    return {
      success: true,
      data: {
        answer,
        tableData: results,
        sql,
        ruleName: rule.intent_name
      }
    };
  } catch (error) {
    logger.error('SQL规则处理错误:', error);
    return {
      success: false,
      error: error.message,
      data: {
        answer: '查询处理失败，请稍后重试',
        tableData: [],
        ruleName: rule.intent_name
      }
    };
  }
}
```

## 9️⃣ 系统优势与特点

### 9.1 技术优势
- **双引擎架构**: MySQL + 内存查询，确保高可用性
- **智能降级**: 数据库失败时自动切换到内存查询
- **分层缓存**: 多级缓存机制提升响应速度
- **容错设计**: 完善的错误处理和恢复机制

### 9.2 业务优势
- **场景驱动**: 基于实际业务场景设计规则体系
- **字段对齐**: 规则输出与前端页面完全匹配
- **实时同步**: 前端数据变化实时反映到查询结果
- **扩展性强**: 规则可配置，易于添加新的查询场景

### 9.3 运维优势
- **监控完善**: 全链路日志和性能监控
- **健康检查**: 多维度系统健康状态检查
- **限流保护**: 分层限流策略保护系统稳定性
- **文档完整**: API文档和系统架构文档齐全

---

**总结**: IQE系统采用了分层架构设计，通过数据同步层、规则库管理层和规则执行引擎的有机结合，实现了从前端数据到智能问答的完整数据流处理。系统具备良好的容错性、扩展性和性能优化特性，能够满足复杂的质量检验业务需求。
